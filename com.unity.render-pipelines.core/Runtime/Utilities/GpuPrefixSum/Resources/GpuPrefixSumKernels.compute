#pragma kernel MainCalculateLevelDispatchArgsFromConst
#pragma kernel MainCalculateLevelDispatchArgsFromBuffer
#pragma kernel MainPrefixSumOnGroup
#pragma kernel MainPrefixSumNextInput
#pragma kernel MainPrefixSumResolveParent

#include "Packages/com.unity.render-pipelines.core/Runtime/Utilities/GpuPrefixSum/GpuPrefixSum.cs.hlsl"

//#pragma enable_d3d11_debug_symbols

ByteAddressBuffer   _InputBuffer;
RWByteAddressBuffer _OutputBuffer;

ByteAddressBuffer _TotalLevelsBuffer;
RWByteAddressBuffer _OutputTotalLevelsBuffer;

RWByteAddressBuffer _OutputDispatchLevelArgsBuffer;

StructuredBuffer<GpuPrefixSumLevelOffsets> _LevelsOffsetsBuffer;
RWStructuredBuffer<GpuPrefixSumLevelOffsets> _OutputLevelsOffsetsBuffer;

float4 _PrefixSumIntArgs0;
float4 _PrefixSumIntArgs1;

#define _InputCount   asint(_PrefixSumIntArgs1.x)
#define _InputOffset  asint(_PrefixSumIntArgs1.y)
#define _OutputOffset asint(_PrefixSumIntArgs1.z)
#define _ParentOffset asint(_PrefixSumIntArgs1.w)

uint DivUpGroup(uint v)
{
    return (v + GROUP_SIZE - 1) / GROUP_SIZE;
}

uint AlignUpGroup(uint v)
{
    return DivUpGroup(v) * GROUP_SIZE;
}

void MainCalculateLevelOffsetsCommon(uint currentCount)
{
    //Assume that the input max elements is already aligned.
    uint alignedSupportMaxCount = AlignUpGroup(currentCount);
    uint totalSize = 0;
    uint levelCounts = 0;

    GpuPrefixSumLevelOffsets offsets;

    bool canReduce = alignedSupportMaxCount > 0;

    [loop]
    while (canReduce)
    {
        GpuPrefixSumLevelOffsets offsets;
        offsets.count = alignedSupportMaxCount;
        offsets.inputOffset = totalSize;
        offsets.outputOffset = totalSize;
        offsets.parentOffset = 0;

        uint groupCount = DivUpGroup(alignedSupportMaxCount);

        _OutputLevelsOffsetsBuffer[levelCounts] = offsets;
        _OutputDispatchLevelArgsBuffer.Store3((levelCounts * 3) << 2, uint3(groupCount,1,1));

        totalSize += alignedSupportMaxCount;
        ++levelCounts;

        alignedSupportMaxCount = AlignUpGroup(groupCount);
        if (alignedSupportMaxCount <= GROUP_SIZE)
            canReduce = false;
    }

    _OutputTotalLevelsBuffer.Store(0, levelCounts);
}

[numthreads(1,1,1)]
void MainCalculateLevelDispatchArgsFromConst()
{
    MainCalculateLevelOffsetsCommon((uint)_InputCount);
}

[numthreads(1,1,1)]
void MainCalculateLevelDispatchArgsFromBuffer()
{
    MainCalculateLevelOffsetsCommon(_InputBuffer.Load(_InputOffset << 2));
}

groupshared uint gs_prefixCache[GROUP_SIZE];

[numthreads(GROUP_SIZE, 1, 1)]
void MainPrefixSumOnGroup(int3 dispatchThreadID : SV_DispatchThreadID, int groupIndex : SV_GroupIndex)
{
    int threadID = dispatchThreadID.x;
    uint inputVal = threadID >= _InputCount ? 0u : _InputBuffer.Load((threadID + _InputOffset) << 2);
    gs_prefixCache[groupIndex] = inputVal;

    GroupMemoryBarrierWithGroupSync();

    //Hillis Steele Scan
    for (int i = 1; i < GROUP_SIZE; i <<= 1)
    {
        uint val = groupIndex >= i ? gs_prefixCache[groupIndex - i] : 0u;
        GroupMemoryBarrierWithGroupSync();

        gs_prefixCache[groupIndex] += val;

        GroupMemoryBarrierWithGroupSync();
    }

    uint outputVal = gs_prefixCache[groupIndex];

#if EXCLUSIVE_PREFIX
    outputVal -= inputVal;
#endif

    _OutputBuffer.Store((threadID + _OutputOffset) << 2, outputVal);
}

[numthreads(GROUP_SIZE, 1, 1)]
void MainPrefixSumNextInput(int3 dispatchThreadID : SV_DispatchThreadID, int3 groupID : SV_GroupID)
{
    _OutputBuffer.Store(dispatchThreadID.x << 2, _InputBuffer.Load((_InputOffset + dispatchThreadID.x * GROUP_SIZE + GROUP_SIZE - 1) << 2));
}

groupshared uint g_parentSum;

[numthreads(GROUP_SIZE, 1, 1)]
void MainPrefixSumResolveParent(int3 dispatchThreadID : SV_DispatchThreadID, int groupIndex : SV_GroupIndex, int3 groupID : SV_GroupID)
{
    //no need to do barriers / etc since groupID will trigger a scalar load. We hope!!
    uint parentSum = groupID.x == 0 ? 0 : _OutputBuffer.Load((_ParentOffset + groupID.x - 1) << 2);
    int index = _OutputOffset + dispatchThreadID.x;
#if EXCLUSIVE_PREFIX
    uint val = _OutputBuffer.Load(index << 2) - _InputBuffer.Load(index << 2);
    _OutputBuffer.Store(index << 2, val + parentSum);
#else
    _OutputBuffer.Store(index << 2, _OutputBuffer.Load(index << 2) + parentSum);
#endif
}
